fastlane_version "2.220.0"

default_platform :ios

require "json"
require "base64"

platform :ios do
  desc "Build and submit BodyLapse to App Store with localized release notes."
  lane :submit_from_ci do
    release_notes = load_release_notes(path: ENV.fetch("RELEASE_NOTES_JSON_PATH", "fastlane/release_notes.json"))

    api_key = app_store_connect_api_key(
      key_id: ENV.fetch("APP_STORE_CONNECT_KEY_ID"),
      issuer_id: ENV.fetch("APP_STORE_CONNECT_ISSUER_ID"),
      key_content: ENV.fetch("APP_STORE_CONNECT_PRIVATE_KEY"),
      is_key_content_base64: true,
      duration: 1200
    )

    sync_code_signing_if_configured(api_key: api_key)

    build_ios_app(
      project: "BodyLapse.xcodeproj",
      scheme: "BodyLapse",
      configuration: "Release",
      clean: true,
      export_method: "app-store",
      output_directory: "build",
      output_name: "BodyLapse.ipa",
      include_bitcode: false,
      include_symbols: true
    )

    upload_to_app_store(
      api_key: api_key,
      ipa: "build/BodyLapse.ipa",
      release_notes: release_notes,
      skip_screenshots: true,
      submit_for_review: true,
      automatic_release: false,
      run_precheck_before_submit: false,
      force: true,
      submission_information: {
        export_compliance_uses_encryption: false
      }
    )
  end

  private_lane :sync_code_signing_if_configured do |options|
    api_key = options[:api_key]
    UI.user_error!("api_key is required for sync_code_signing_if_configured") if api_key.nil?

    match_git_url = ENV["MATCH_GIT_URL"].to_s.strip
    if match_git_url.empty?
      UI.important("MATCH_GIT_URL is not set. Skipping match; expecting signing assets on runner.")
      return
    end

    match_options = {
      type: "appstore",
      readonly: true,
      api_key: api_key,
      git_url: match_git_url,
      app_identifier: [ENV.fetch("APP_IDENTIFIER", "com.J.BodyLapse")]
    }

    match_git_auth = ENV["MATCH_GIT_BASIC_AUTHORIZATION"].to_s.gsub(/\s+/, "").strip
    if match_git_auth.downcase.start_with?("basic")
      match_git_auth = match_git_auth[5..].to_s.strip
    end
    unless match_git_auth.empty?
      token_prefixes = ["ghp_", "gho_", "ghu_", "ghs_", "github_pat_"]
      encode_basic = lambda { |credential| Base64.strict_encode64(credential) }
      classify_token = lambda do |value|
        token_prefixes.any? { |prefix| value.start_with?(prefix) }
      end

      # 互換対応:
      # - Base64済みの "username:token" 文字列
      # - 生の "username:token" 文字列
      # - 生のGitHub PAT
      # - PATのみをBase64化してしまった値
      if classify_token.call(match_git_auth)
        UI.important("MATCH_GIT_BASIC_AUTHORIZATION detected as raw GitHub token.")
        match_options[:git_basic_authorization] = encode_basic.call("x-access-token:#{match_git_auth}")
      elsif match_git_auth.include?(":")
        UI.important("MATCH_GIT_BASIC_AUTHORIZATION detected as plain username:token.")
        match_options[:git_basic_authorization] = encode_basic.call(match_git_auth)
      else
        begin
          decoded = Base64.strict_decode64(match_git_auth)
          user, token = decoded.split(":", 2)

          if !user.to_s.empty? && !token.to_s.empty?
            UI.important("MATCH_GIT_BASIC_AUTHORIZATION detected as Base64 username:token.")
            match_options[:git_basic_authorization] = match_git_auth
          elsif classify_token.call(decoded)
            UI.important("MATCH_GIT_BASIC_AUTHORIZATION detected as Base64 raw token.")
            match_options[:git_basic_authorization] = encode_basic.call("x-access-token:#{decoded}")
          else
            UI.important("MATCH_GIT_BASIC_AUTHORIZATION decoded but format is unknown. Treating as raw token.")
            match_options[:git_basic_authorization] = encode_basic.call("x-access-token:#{match_git_auth}")
          end
        rescue ArgumentError
          UI.important("MATCH_GIT_BASIC_AUTHORIZATION is not valid Base64. Treating as raw token.")
          match_options[:git_basic_authorization] = encode_basic.call("x-access-token:#{match_git_auth}")
        end
      end
    end

    match(**match_options)
  end

  private_lane :load_release_notes do |options|
    path = options[:path].to_s
    UI.user_error!("Release notes path is missing.") if path.empty?
    UI.user_error!("Release notes file not found: #{path}") unless File.exist?(path)

    data = JSON.parse(File.read(path))
    required_locales = ["ja", "en-US", "es-ES", "ko"]
    missing = required_locales.reject { |locale| data.key?(locale) && !data[locale].to_s.strip.empty? }
    UI.user_error!("Missing locales in release notes JSON: #{missing.join(', ')}") unless missing.empty?

    data
  end
end
